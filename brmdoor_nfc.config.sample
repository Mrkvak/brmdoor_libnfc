# auth_db_filename - sqlite filename of authorized UIDs, create with create_authenticator_db.py
# lock_opened_secs - how long lock should be held open in seconds, default 5
# unknown_uid_timeout_secs - how long to wait after scanning unknown UID - 
#       prevents too many messages
# log_file - logs read UIDs and when was lock opened, use - for stderr
# log_level - minimum log level - one of debug, info, warn, error, fatal, default info
# unlocker - which unlocker class to use - Unlocker or UnlockerWiringPi
#	Unlocker is just dummy test class. 
[brmdoor]
auth_db_filename = test_uids_db.sqlite
#corresponding private key = 10ee85f987e7682d9acf24ab07ff0e302ee4cdd426f83a055d3a337a4f01314b
desfire_ed25519_pubkey = 4c625187d79fdee97a6af48cb8f854e7f313c8158de94e667e1509bd26617d27
#lock_opened_secs = 5
#unknown_uid_timeout_secs = 5
log_file = -
#log_level = info
unlocker = UnlockerWiringPi

# Config section for dummy unlocker. It has no options.
[Unlocker]

# Config for wiringPi-based unlocker
# lock_pin - which pin needs to be pulled high to disengage the lock (GPIO numbering)
[UnlockerWiringPi]
lock_pin = 17

[irc]
# enabled - True or False; rest of the options are not necessary if set to False
# server - IRC server to connect to
# port - IRC server port
# nick - nickname of bot
# password - password for the nick, may be omitted
# channels - space separated list of channels to join
# tls - True or False whether we should connect over TLS
# reconnect_delay - wait this many seconds until next reconnect attempt
enabled = True
server = irc.freenode.net
port = 6697
nick = bjornbot
password = whatevs
channels = #test-bjornbot
tls = True
reconnect_delay = 300

[open_switch]
# Controls showing status of "OPEN/CLOSE" switch that is connected to some GPIO pin
# Changes topic of connected IRC channels if IRC is enabled
# There is no point in enabling this if you disabled IRC
# Still has one bug - python-irc won't retrieve properly topic
# enabled - True/False
# status_file - file that contains value of the button, may end with newline (you probably want something in /sys fs)
# open_value - which value in status_file represents the switch being in "OPEN" position, anything else is considered closed
#
# Note: for use with Raspberry Pi, to read from GPIO in sysfs, you need to enable the PIN in input mode before starting
# brmdoor_nfc_daemon.py, e.g. with GPIO 11 as an example (note that there are 2 numbering PIN schemes):
#    #!/bin/bash
#    export PIN=11
#
#    if [ '!' -d /sys/class/gpio/gpio$PIN ]; then
#        echo $PIN > /sys/class/gpio/export
#        echo in > /sys/class/gpio/gpio$PIN/direction
#    fi

enabled = False
status_file = /sys/class/gpio/gpio11/value
open_value = 1
